import { ItemType, PropName, PropValue, StepName } from "../types";
export declare function makeEffectsMaker<T_ItemType extends ItemType & string, T_PropName extends PropName<T_ItemType> & string, T_PropValue extends EnsureString<PropValue<T_ItemType, T_PropName>>, T_StepName extends StepName, T_UsefulParams extends Record<any, any>>(storeName: T_ItemType, storeItemId: string, storyProperty: T_PropName, stepName?: T_StepName, getUsefulParams?: () => T_UsefulParams): (callbacksMap: Partial<Record<EnsureString<T_PropValue>, (usefulStuff: T_UsefulParams) => void>>) => Record<"whenPropertyChanges", import("../types").EffectDef>;
export declare function makeLeaveEffectsMaker<T_ItemType extends ItemType & string, T_PropName extends PropName<T_ItemType>, T_PropValue extends EnsureString<PropValue<T_ItemType, T_PropName>>, T_StepName extends StepName, T_UsefulParams extends Record<any, any>>(storeName: T_ItemType, storeItemId: string, storyProperty: T_PropName, stepName?: T_StepName, getUsefulParams?: () => T_UsefulParams): (callBacksObject: Partial<Record<EnsureString<T_PropValue>, (usefulStuff: T_UsefulParams) => void>>) => Record<"whenPropertyChanges", import("../types").EffectDef>;
type EnsureString<T> = T extends string ? T : never;
/** Similar to makeEffectsMaker but accepts parameters for two store properties (can be from different stores) , and the callback fires when properties of both stores change */
export declare function makeNestedEffectsMaker<T_ItemType1 extends ItemType & string, T_PropName1 extends PropName<T_ItemType1> & string, T_PropValue1 extends EnsureString<PropValue<T_ItemType1, T_PropName1>>, T_ItemType2 extends ItemType & string, T_PropName2 extends PropName<T_ItemType2> & string, T_PropValue2 extends EnsureString<PropValue<T_ItemType2, T_PropName2>>, T_StepName extends StepName, T_UsefulParams extends Record<any, any>>(storeInfo1: [T_ItemType1, string, T_PropName1], storeInfo2: [T_ItemType2, string, T_PropName2], stepName?: T_StepName, getUsefulParams?: () => T_UsefulParams): (callBacksObject: Partial<Record<EnsureString<T_PropValue1>, Partial<Record<EnsureString<T_PropValue2>, (usefulStuff: ReturnType<NonNullable<typeof getUsefulParams>>) => void>>>>) => Record<"whenPropertyChanges", import("../types").EffectDef>;
/** The same as makeNestedRuleMaker , but the callback fires when the properties of both stores become NOT the specified values, but were previously */
export declare function makeNestedLeaveEffectsMaker<T_ItemType1 extends ItemType & string, T_PropName1 extends PropName<T_ItemType1> & string, T_ItemType2 extends ItemType & string, T_PropName2 extends PropName<T_ItemType2> & string, T_UsefulParams extends Record<any, any>>(storeInfo1: [T_ItemType1, string, T_PropName1], storeInfo2: [T_ItemType2, string, T_PropName2], stepName?: StepName, getUsefulParams?: () => T_UsefulParams): (callBacksObject: Partial<Record<any, Partial<Record<any, (usefulStuff: T_UsefulParams) => void>>>>) => Record<"whenPropertyChanges", import("../types").EffectDef>;
export {};
